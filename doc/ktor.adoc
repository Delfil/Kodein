= Kodein DI on Ktor
Romain BOISSELLE <romain@boisselle.dev>
:toc: left
:toc-position: left
:toclevels: 5

:version: 6.1.0
:branch: 6.1

You can use Kodein as-is in your Ktor project, but you can level-up your game by using the library `kodein-di-ktor-server-jvm`.

NOTE: Kodein does work on Ktor as-is.
      The `kodein-di-ktor-server-jvm` extension adds multiple ktor-specific utilities to Kodein. +
      Using or not using this extension really depends on your needs.

NOTE: Ktor is a multiplatform project, meaning you can use it for JVM, JS and Native projects.
      Please note that, at the moment, Kodein utilities are only available for the JVM platform, for the server cases precisely

Have a look at the https://github.com/Kodein-Framework/Kodein-DI/tree/{branch}/demo/demo-ktor[Ktor demo project] to help you going further!

[[install]]
== Install

.How to quickly get into `kodein-di-ktor-server-jvm`:
. Add this line in your `dependencies` block in your application `build.gradle` file:
+
[subs="attributes"]
.Gradle Groovy script
----
implementation 'org.kodein.di:kodein-di-ktor-server-jvm:{version}'
----
+
[subs="attributes"]
.Gradle Kotlin script
----
implementation(project("org.kodein.di:kodein-di-ktor-server-jvm:{version}"))
----
+
IMPORTANT: Either `kodein-di-generic-jvm` or `kodein-di-erased-jvm` *must* be declared in addition to the `kodein-di-ktor-server-jvm` package.
+
. Declare a Kodein container in your application or use the <<kodeinfeature>>
+
[source, kotlin]
.Example: a Ktor Application declaration, with Kodein container declaration
----
fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8080) {
        val kodein = Kodein {
            /* bindings */
        }
   }.start(true)
}
----
[source, kotlin]
.Example: a Ktor Application declaration, installing the `KodeinFeature`
----
fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8080) {
        install(KodeinFeature) {
            /* bindings */
        }
   }.start(true)
}
----

. In your application, routes, etc. retrieve your Kodein object!

. Retrieve your dependencies!

== Retrieving

You can always get the `Kodein` object by using:

- `kodein()` inside a Ktor class (such as `Application`, `ApplicationCall`, `Route`, etc.)
- `kodein { application }` inside another class

CAUTION: The `kodein` function will only work if your Ktor `Application` has the `KodeinFeature` installed

== Ktor scopes

=== Session scopes

With the `kodein-ktor` utils you can scope your dependencies upon your Ktor sessions. To do that you'll have to follow the steps:

. Defining your session and scope your dependencies

[source, kotlin]
.Example: Defining the session and scope dependencies
----
data class UserSession(val user: User) : KtorSession { <1>
    override fun getSessionId() = user.id <2>
}

fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8000) {
        install(Sessions) { <3>
            cookie<UserSession>("SESSION_FEATURE_SESSION_ID") <4>
        }
        install(KodeinFeature) {
            bind<Random>() with scoped(SessionScope).singleton { SecureRandom() } <5>
            /* binding */
        }
    }.start(true)
}
----
<1> Create session object that implements `KtorSession`
<2> Implement the function `getSessionId()`
<3> Install the `Sessions` feature
<4> Declaring a session cookie represented by `UserSession`
<5> Bind `Random` object scoped by `SessionScope`

. Retrieving your scoped dependencies

[source, kotlin]
.Example: Retrieving scoped dependencies
----
embeddedServer(Netty, port = 8000) {
    /* configurations */
    routing {
        get("/random") {
            val session = call.sessions.get<UserSession>() ?: error("no session found!") <1>
            val random by kodein().on(session).instance<Random>() <2>
            call.responText("Hello ${session.user.name", your random number is ${random.nextInt()}")
        }
    }
}.start(true)
----
<1> Retrieve the `session` from the request context or fail
<2> retrieve a `Random` object from the `Kodein` object scoped by `session`

. Clear the scope as long as the sessions are no longer used

A Ktor session is cleared by calling the function `CurrentSession.clear<Session>()`.
To clear the session combine to the scope removal you can use the function `CurrentSession.clearSessionAndScope<Session>()`, 
thus the session will be cleared and the `ScopeRegistry` removed.

[source, kotlin]
.Example: Clear the session and scope
----
get("/clear") {
    call.sessions.clearSessionScope<UserSession>()
}
----
<1> clear the session and remove the `ScopeRegistry` linked to the session

=== Request scope

Kodein provides a standard scope for any object (Ktor or not).
The `WeakContextScope` will keep singleton and multiton instances as long as the context (= object) lives.

That's why the `RequestScope` is just a wrapper upon `WeakContextScope` with the target `ApplicationCall`, that lives only along the Request (HTTP or Websocket).

[source, kotlin]
.Example: using a Request scope
----
val kodein = Kodein {
    bind<Random>() with scoped(RequestScope).singleton { SecureRandom() } <1>
}
----
<1> A `Random` object will be created for each `Request` and will be retrieved as long as the `Request` lives.