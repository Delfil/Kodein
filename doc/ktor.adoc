= Kodein DI on Ktor
Romain BOISSELLE <romain@boisselle.dev>
:toc: left
:toc-position: left
:toclevels: 5

:version: 6.1.0
:branch: 6.1

You can use Kodein as-is in your Ktor project, but you can level-up your game by using the library `kodein-di-ktor-server-jvm`.

NOTE: Kodein does work on Ktor as-is.
      The `kodein-di-ktor-server-jvm` extension adds multiple ktor-specific utilities to Kodein. +
      Using or not using this extension really depends on your needs.

NOTE: Ktor is a multiplatform project, meaning you can use it for JVM, JS and Native projects.
      Please note that, at the moment, Kodein utilities are only available for the JVM platform, for the server cases precisely

Have a look at the https://github.com/Kodein-Framework/Kodein-DI/tree/{branch}/demo/demo-ktor[Ktor demo project] to help you going further!

[[install]]
== Install

.How to quickly get into `kodein-di-ktor-server-jvm`:
. Add this line in your `dependencies` block in your application `build.gradle` file:
+
[subs="attributes"]
.Gradle Groovy script
----
implementation 'org.kodein.di:kodein-di-generic-jvm:{version}'
implementation 'org.kodein.di:kodein-di-ktor-server-jvm:{version}'
----
+
[subs="attributes"]
.Gradle Kotlin script
----
implementation(project("org.kodein.di:kodein-di-generic-jvm:{version}"))
implementation(project("org.kodein.di:kodein-di-ktor-server-jvm:{version}"))
----
+
IMPORTANT: Either `kodein-di-generic-jvm` or `kodein-di-erased-jvm` *must* be declared in addition to the `kodein-di-ktor-server-jvm` package.
+
. Declare a Kodein container in your application or use the <<kodeinfeature>>
+
[source, kotlin]
.Example: a Ktor Application declaration, with Kodein container declaration
----
fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8080) {
        val kodein = Kodein {
            /* bindings */
        }
   }.start(true)
}
----
[source, kotlin]
.Example: a Ktor Application declaration, installing the `KodeinFeature`
----
fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8080) {
        install(KodeinFeature) {
            /* bindings */
        }
   }.start(true)
}
----

. In your application, routes, etc. retrieve your Kodein object!

. Retrieve your dependencies!

[[kodeinfeature]]
== `KodeinFeature`

As a Ktor https://ktor.io/servers/application.html[Application] is based on extensions we cannot use the `KodeinAware` mechanism on it.
So, we had to find another, elegant, way to provide a global Kodein container. That's where the `KodeinFeature` stands.
It allows developers to create an instance of a Kodein container, that will be available from anywhere in their Ktor app.

To help with that, the `kodein-di-ktor-server-jvm` provides a https://ktor.io/advanced/features.html[custom feature]
that will create and register an instance of a Kodein container in the application's https://ktor.io/advanced/pipeline/attributes.html[attributes].
Thus, the Kodein will be reachable from multiple places like:

- Application
- ApplicationCall
- Routing / Routes

[source, kotlin]
.Example: a Ktor Application declaration, installing the `KodeinFeature`, and retrieving it from routes
----
fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8080) {
        install(KodeinFeature) { // <1>
            bind<Random>() with singleton { SecureRandom() } // <2>
        }

        routing {
            get("/") {
                val random by kodein().instance<Random>() // <3>
                /* logic here */
            }
        }
   }.start(true)
}
----
<1> Install the `KodeinFeature`
<2> Lambda that represent a Kodein builder, accepting Kodein core features
<3> retrieving the Kodein container from the Application by calling `PipelineContext<*, ApplicationCall>.kodein()` extension function

.Available `kodein()` extension function receivers
- https://ktor.io/servers/application.html#application[Application]

    fun Application.main() {
        /* usage */
        val kodein = kodein()

        /* other usage */
        val random by kodein().instance<Random>()
    }

- https://ktor.io/advanced/pipeline.html#interceptors-and-the-pipelinecontext[PipelineContext<*, ApplicationCall>]

    get {
        /* usage */
        val kodein = context.kodein()

        /* other usage */
        val random by context.kodein().instance<Random>()
    }

- https://ktor.io/servers/calls.html[ApplicationCall]

    get("/") {
        /* usage */
        val kodein = kodein()

        /* other usage */
        val random by kodein().instance<Random>()
    }

- https://ktor.io/servers/features/routing.html[Routing]

    routing {
        /* usage */
        val kodein = kodein()

        /* other usage */
        val random by kodein().instance<Random>()
    }

NOTE: Because of those extension functions you can always get the Kodein object by using:
    - `kodein()` inside a Ktor class (such as `Application`, `ApplicationCall`, `Route`, etc.)
    - `kodein { application }` inside another class

WARNING: The `kodein()` function will only work if your Ktor `Application` has the `KodeinFeature` installed

== Ktor scopes

=== Session scopes

With the `kodein-di-ktor-server-jvm` utils you can scope your dependencies upon your Ktor sessions. To do that you'll have to follow the steps:

. Defining your session and scope your dependencies

[source, kotlin]
.Example: Defining the session and scope dependencies
----
data class UserSession(val user: User) : KtorSession { <1>
    override fun getSessionId() = user.id <2>
}

fun main(args: Array<String>) {
    embeddedServer(Netty, port = 8000) {
        install(Sessions) { <3>
            cookie<UserSession>("SESSION_FEATURE_SESSION_ID") <4>
        }
        install(KodeinFeature) {
            bind<Random>() with scoped(SessionScope).singleton { SecureRandom() } <5>
            /* binding */
        }
    }.start(true)
}
----
<1> Create session object that implements `KtorSession`
<2> Implement the function `getSessionId()`
<3> Install the `Sessions` feature
<4> Declaring a session cookie represented by `UserSession`
<5> Bind `Random` object scoped by `SessionScope`

. Retrieving your scoped dependencies

[source, kotlin]
.Example: Retrieving scoped dependencies
----
embeddedServer(Netty, port = 8000) {
    /* configurations */
    routing {
        get("/random") {
            val session = call.sessions.get<UserSession>() ?: error("no session found!") <1>
            val random by kodein().on(session).instance<Random>() <2>
            call.responText("Hello ${session.user.name", your random number is ${random.nextInt()}")
        }
    }
}.start(true)
----
<1> Retrieve the `session` from the request context or fail
<2> retrieve a `Random` object from the `Kodein` object scoped by `session`

. Clear the scope as long as the sessions are no longer used

A Ktor session is cleared by calling the function `CurrentSession.clear<Session>()`.
To clear the session combine to the scope removal you can use the function `CurrentSession.clearSessionAndScope<Session>()`, 
thus the session will be cleared and the `ScopeRegistry` removed.

[source, kotlin]
.Example: Clear the session and scope
----
get("/clear") {
    call.sessions.clearSessionScope<UserSession>()
}
----
<1> clear the session and remove the `ScopeRegistry` linked to the session

=== Call scope

Kodein provides a standard scope for any object (Ktor or not).
The `WeakContextScope` will keep singleton and multiton instances as long as the context (= object) lives.

That's why the `RequestScope` is just a wrapper upon `WeakContextScope` with the target `ApplicationCall`, that lives only along the Request (HTTP or Websocket).

[source, kotlin]
.Example: using a Request scope
----
val kodein = Kodein {
    bind<Random>() with scoped(RequestScope).singleton { SecureRandom() } <1>
}
----
<1> A `Random` object will be created for each `Request` and will be retrieved as long as the `Request` lives.