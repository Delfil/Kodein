= Kodein DI on TornadoFX
Romain BOISSELLE <romain@boisselle.dev>
:toc: left
:toc-position: left
:toclevels: 5

:version: 6.2.0
:branch: 6.2

You can use Kodein as-is in your TornadoFX project, but you can level-up your game by using the libraries `kodein-di-framework-tornadofx-core`.

NOTE: Kodein does work on TornadoFX as-is.
      The `kodein-di-framework-tornadofx-core` extensions add multiple TornadoFX-specific utilities to Kodein. +
      Using or not using this extension really depends on your needs.

Have a look at the https://github.com/Kodein-Framework/Kodein-DI/tree/{branch}/demo/demo-tornadofx[TornadoFX demo project] to help you going further!

[[install]]
== Install

.How to quickly get into `kodein-di-framework-tornadofx-core`:
. Add this line in your `dependencies` block in your application `build.gradle` file:
+
[subs="attributes"]
.Gradle Groovy script
----
implementation 'org.kodein.di:kodein-di-generic-jvm:{version}'
implementation 'kodein-di-framework-tornadofx-core:{version}'
----
+
[subs="attributes"]
.Gradle Kotlin script
----
implementation("org.kodein.di:kodein-di-generic-jvm:{version}")
implementation("kodein-di-framework-tornadofx-core:{version}")
----
+
IMPORTANT: either `kodein-di-generic-jvm` or `kodein-di-erased` *must* be declared in addition to the `kodein-di-framework-tornadofx-core` package.
+
. Declare your `App` as `KodeinAware` and implement a Kodein container
+
[source, kotlin]
.Example: a TornadoFX Application declaration, `KodeinAware`, using TornadoFX DI as external source
----
class TornadoApplication : App(MainView::class), KodeinAware { // <1>
    override val kodein: Kodein get() = Kodein { // <2>
        extend(tornadoFXExternalSource) // <3>
     } 
}
----
<1> Setting the `App` as `KodeinAware` will help you define a global Kodein container
<2> Define a Kodein container, accessible from almost anywhere in your application
<3> Branch Kodein upon TornadoFX dependency injection, to be able to access those dependencies through your Kodein container (see link:tornadofx.adoc#external-source[documentation])

WARNING: In order to leverage the power of Kodein and the helpers we made, you should really consider making your `App` as `KodeinAware`.

[[retrieving]]
== Retrieving

If you defined your `App` as `KodeinAware`, you will normally be able to retrieve a Kodein container, and dependencies, from almost anywhere in your code.

CAUTION: You may also want to access your TornadoFX components (such as `View`, `Fragment`, `Controller`, etc) through a Kodein container, to help you with that check the link:tornadofx.adoc#external-source[external source] section.

[[closest-kodein]]
=== Closest Kodein pattern

The idea behind this concept, is to be able to retrieve a Kodein container, from an outer class. For example, making our `App` as `KodeinAware` give us the ability to have a global Kodein container that can be retrieve from multiple places, like:

- Components (`View`, `Fragment`, `Controller`, etc)
- Nodes, graphical object of the `App`

[[closest-tfx]]
==== From a TornadoFX perspective

In TornadoFX there is no hierachy between the different components. In fact, their is no bound between `View`, `Fragment`, `Controller` or `ViewModel`, except if you handle it yourself. However, they are available thourgh the DI container of TornadoFX (and the one of Kodein if you use link:tornadofx.adoc#external-source[external source] helper), and they all have a reference to the `App`.

So, if we made our `App` as `KodeinAware`, we can get the global `Kodein` container from any `Component` thanks to:

[source, kotlin]
.Code: Extension function on `Component` that get the Kodein container from the `App`, if its `KodeinAware`
----
fun Component.kodein() = kodein { app }
----

[NOTE]
====
TornadoFX `Component` are:

- View
- Fragment
- Controller
- ViewModel
====

In your code you can access the global Kodein container like the following snippets.

[source, kotlin]
.Example: retrieving dependency through closest Kodein container from a `Controller`
----
class PersonController : Controller() {
    val repository: PersonRepository by kodein().instance() // <1>
}
----
<1> The `kodein()` function that will get the nearest Kodein container, from the `App` 

[source, kotlin]
.Example: retrieving dependency through the closest Kodein container from a `View`
----
class PersonEditorView : View() {
    val controller: PersonController by kodein().instance() // <1>
}
----
<1> The `kodein()` function will get the nearest Kodein container, from the `App`

CAUTION: All TornadoFX `Component` can access the global Kodein container ) by calling the function `kodein()`, but your `App` *must* be `KodeinAware`.

[[closest-jfx]]
==== From a JavaFX perspective

In JavaFX, an `Application` is made of a `Stage` (the window), a `Scene` (the container for all content) and a graph of `Node`. All `Node` are grouped by view (in the case of TornadoFX: `View` or `Fragment`). 

So, the `Node` hierarchy can apply to the closest Kodein pattern, limited to the scope of a `View` or `Fragment` for now. If none of the parent `Node` have a `Kodein` container, thanks to the TornadoFX facilities, we can fallback onto the global Kodein container from the `App`.

[source, kotlin]
.Example: retrieving dependency through the closest Kodein container from a `Node`
----
class EditorTabFragment : Fragment() {
    override val root = hbox {
        form {
            val author: String by kodein().instance("author") // <1>
            label { author }
        }
    }
}
----
<1> The `kodein()` function will get the nearest Kodein container, from the parent `Node`, or from the `App`

CAUTION: If none of the parent nodes have a Kodein container, we try to get to the one in the `App`, only if this `App` is `KodeinAware`.

[[kodein-extension]]
== Extension of Kodein

This section will cover how we can extend the use of Kodein in a TornadoFX application, like:

- Getting control of dependency injection over TornadoFX

- Defining specific Kodein containers in a TornadoFX / JavaFX graph

- Overriding a parent Kodein container in a TornadoFX component / JavaFX node

[[external-source]]
=== Using TornadoFX Dependency Injection as external source

[[fx-container]]
=== Defining Kodein container in FX's `Node`

For some need we could want to define Kodein containers into the `Node` hierarchy. To do so we provide an extension function to create a Kodein container attached to a `Node`. This is done by adding the Kodein container to the properties of the `Node`, thus we will be able to access it from any child in the hierarachy.

[source, kotlin]
.Example: Defining and using a Kodein container from a `Node`
----
class MyView : View() {
    override val root = hbox { // <1>
        kodein { // <2>
            bind<Random>() with singleton { SecureRandom() }
        }
        
        form { // <3>
            val random by kodein().instance<Random>() // <4>
        }
    }
}
----
<1> Defining the root `Node` for a `View`
<2> Declaring a *new* Kodein container into the root `Node`, with its binding
<3> Defining a child `Node`
<4> Calling the `kodein()` extension function to access the nearest Kodein container, in this case the one defined at <2>, then retrieve a dependency

IMPORTANT: This feature will provide a *new* Kodein container, meaning it won't be linked to other Kodein container, such as your global one. To keep your binding from the global Kodein container you can use link:tornadofx.adoc#core#_extension_composition[extension] or following the next about core#sub-kodein[subKodein]

[[sub-kodein]]
=== Extending the nearest Kodein container

Some times, we might want to extend an existing Kodein container in a dedicated area, without impacting the whole application. For example, in a login form, we might want to have credentials binding, that would be only available on this form and its children.

To do so, we have facilities to extend a Kodein container by calling the `subKodein` extension function, available on `Component` and `Node` classes.

. In the case of a `Component`
+
[source, kotlin]
.Example: Extending the nearest Kodein container for a `Component`
----
class LoginController : Controller(), KodeinAware { // <1>
    override val kodein: Kodein = subKodein { // <2>
            bind<CredentialsDao> with singleton { CredentialsDao() } <3>
    }
    
    // ...

    val dao by kodein.instance<CredentialsDao>() // <4>
}
----
<1> Defining your `Component` as `KodeinAware` will help keeping track of your extended Kodein container
<2> Extending the nearest Kodein container, here the `App` one
<3> Defining binding only available for the extended Kodein container
<4> Retrieve the `CredentialsDao` from the Kodein container
+
NOTE: Making your `Component` as `KodeinAware` is *optional*, but it will help you keeping track of your extended container. Otherwise, you might want to store a reference of your extended container in a local variable.

. In the case of a `Node` hierarchy 
+
[source, kotlin]
.Example: Extending the nearest Kodein container for a `Node`
----
class LoginView : View() {
    override val root = hbox { // <1>
        subKodein { // <2>
            bind<LoginController>() with singleton { instance() } // <3>
        }
        
        form {
            val controller by kodein().instance<LoginController>() <4>
        }
    }
}
----
<1> Defining the root `Node` for a `View`
<2> Extending the nearest Kodein container, here the `App` one, but stored in the `Node` properties
<3> Defining binding only available for the extended Kodein container
<4> Retrieve the `CredentialsDao` from the nearest Kodein container, in that case the extended container stored in the *hbox* properties

IMPORTANT: In the case of a `Component` you have to handle the reference of the extended comtainer yourself. But, in the case of a `Node` the `subKodein` will manage it, by storing the reference to the extended container, into the `Node` properties, like for the link:tornadofx.adoc#fx-container[FX container feature]

[[scopes]]
== TornadoFX scopes